package de.rwth.i5.kinectvision.mqtt;


import de.rwth.i5.kinectvision.machinevision.model.BoundingSphere;
import de.rwth.i5.kinectvision.machinevision.model.Marker3d;
import de.rwth.i5.kinectvision.robot.Robot;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.springframework.boot.configurationprocessor.json.JSONArray;
import org.springframework.boot.configurationprocessor.json.JSONException;
import org.springframework.boot.configurationprocessor.json.JSONObject;

import javax.vecmath.Vector3d;
import java.util.ArrayList;

/**
 * Class used as an MQTT client for the Kinect data. It subscribes to the data generated by the Kinect.
 */
@Slf4j
public class SwevaClient {
    @Setter
    private String broker;
    @Setter
    private String clientId;
    int scale = 100;
    int scaleH = 200;
    private MqttClient swevaClient;

    /**
     * Initialization method for the MQTT client. Connects to the broker.
     *
     * @throws MqttException
     */
    public void initialize() throws MqttException {
        //Initialize the Mqtt client and establish a connection
        swevaClient = new MqttClient(broker, clientId, null);
        MqttConnectOptions connOpts = new MqttConnectOptions();
        connOpts.setCleanSession(true);
        swevaClient.connect(connOpts);
    }

    /**
     * Method for sending data to SWEVA
     *
     * @param spheres   The spheres of the robot
     * @param humanList The list containing the human points
     * @param distance  The minimal distance between robot and human
     * @throws JSONException If some value could not be converted
     */
    public void publish(ArrayList<BoundingSphere> spheres, ArrayList<Vector3d> humanList, double distance) throws JSONException {
        publish(null, spheres, humanList, distance);
    }

    /**
     * Method for sending data to SWEVA
     *
     * @param rob       The robot object
     * @param spheres   The spheres of the robot
     * @param humanList The list containing the human points
     * @param distance  The minimal distance between robot and human
     * @throws JSONException If some value could not be converted
     */
    public void publish(Robot rob, ArrayList<BoundingSphere> spheres, ArrayList<Vector3d> humanList, double distance) throws JSONException {
        JSONObject object = new JSONObject();

        JSONObject humans = new JSONObject();


        if (distance == Double.POSITIVE_INFINITY) {
            object.put("distance", -1);
        } else {
            object.put("distance", distance);
        }
        //Add human points
        JSONArray points = new JSONArray();
        humans.put("points", points);
        object.put("humans", humans);

        JSONArray pointsOneHum = new JSONArray();
        points.put(pointsOneHum);
        int count = 0;
        if (humanList != null) {
            for (Vector3d vector3d : humanList) {
                if (count++ == 100) {
                    count = 0;
                    pointsOneHum.put(vectorToArray(vector3d, scaleH));
                }
            }
            humans.put("count", humanList.size() > 0 ? 1 : 0);
        } else {
            humans.put("count", 0);
        }

        //Add robot stuff
        JSONObject robot = new JSONObject();
        object.put("robot", robot);
        //The spheres
        JSONArray spheresArray = new JSONArray();
        robot.put("spheres", spheresArray);
        for (BoundingSphere sphere : spheres) {
            spheresArray.put(sphereToArray(sphere, scale));
        }

        //Add the markers
        JSONArray markersArray = new JSONArray();
        robot.put("markers", markersArray);
        if (rob != null && rob.getBases() != null) {
            for (Marker3d marker3d : rob.getBases()) {
                markersArray.put(vectorToArray(marker3d.getPosition(), scale));
            }
        }

        //Send it!
        try {
            swevaClient.publish("sweva1", object.toString().getBytes(), 0, false);
        } catch (MqttException e) {
            e.printStackTrace();
        }

    }

    /**
     * Converts a sphere to an array. The vector of the sphere and the radius are being scaled by a factor.
     *
     * @param sphere The sphere object
     * @param scale  The scale factor
     * @return The converted JSONArray
     */
    private JSONArray sphereToArray(BoundingSphere sphere, int scale) {
        JSONArray res = new JSONArray();
        res.put((int) (sphere.getCenter().x * scale));
        res.put((int) (sphere.getCenter().y * scale));
        res.put((int) (sphere.getCenter().z * scale));
        res.put((int) (sphere.getRadius() * scale));
        return res;
    }

    /**
     * Converts a vector to an array. The vector is being scaled by a factor.
     *
     * @param vector3d The vector
     * @param scale    The scale factor
     * @return The converted JSONArray
     */
    public JSONArray vectorToArray(Vector3d vector3d, int scale) {
        JSONArray res = new JSONArray();
        res.put(((int) (vector3d.x * scale)));
        res.put(((int) (vector3d.y * scale)));
        res.put(((int) (vector3d.z * scale)));
        return res;
    }
}
